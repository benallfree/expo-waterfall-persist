{"version":3,"file":"expo-waterfall-persist.dev.js","sources":["../src/index.js"],"sourcesContent":["import { FileSystem } from 'expo'\nimport { default as baseCreateStore } from 'react-waterfall'\nimport _ from 'lodash'\n\nfunction createStoreAsync(config, options = {}) {\n  const defaults = {\n    Log: {\n      debug() {\n        console.log.apply(null, arguments)\n      },\n      error() {\n        console.error.apply(null, arguments)\n      }\n    },\n    fileUri: `${FileSystem.documentDirectory}/state.json`,\n    debounce: {\n      wait: 250,\n      maxWait: 1000\n    },\n    onSaveError: e => {\n      this.Log.error(e)\n      throw e\n    },\n    onLoadError: e => {\n      this.Log.error(e)\n      throw e\n    }\n  }\n  const opts = _.merge({}, defaults, options)\n\n  return new Promise((resolve, reject) => {\n    const { fileUri, Log, onLoadError, onSaveError } = opts\n    Log.debug(`Loading state from ${fileUri}`)\n    new Promise((resolve, reject) => {\n      FileSystem.readAsStringAsync(fileUri)\n        .then(s => {\n          let state = JSON.parse(s)\n          if (!state || state.version != config.initialState.version) {\n            Log.debug(\n              `State verison differs (${state.version} vs ${\n                config.initialState.version\n              }, discarding.`\n            )\n          } else {\n            Log.debug('State restored', state)\n            config.initialState = { ...state }\n          }\n\n          resolve(config)\n        })\n        .catch(e => {\n          if (e.code === 'E_FILE_NOT_READ') {\n            Log.debug('No saved state found, using defaults.')\n          } else {\n            onLoadError(e)\n          }\n          resolve(config)\n        })\n    }).then(config => {\n      let stateMirror = _.merge({}, config.initialState)\n      Log.debug('Waterfall Config', config)\n      const Waterfall = baseCreateStore(config)\n\n      let save = _.debounce(\n        () => {\n          FileSystem.writeAsStringAsync(fileUri, JSON.stringify(stateMirror))\n            .then(() => {\n              Log.debug('State persisted', stateMirror)\n            })\n            .catch(onSaveError)\n        },\n        opts.debounce.wait,\n        { maxWait: opts.debounce.maxWait }\n      )\n      Waterfall.subscribe(function(actionName, stateFragmentResult) {\n        Log.debug('saved to mirror', stateFragmentResult)\n        _.merge(stateMirror, stateFragmentResult)\n        save()\n      })\n      resolve(Waterfall)\n    })\n  })\n}\n\nexport { createStoreAsync }\n"],"names":["createStoreAsync","config","options","defaults","log","apply","arguments","error","FileSystem","documentDirectory","Log","e","opts","_","merge","Promise","resolve","reject","fileUri","onLoadError","onSaveError","debug","readAsStringAsync","then","state","JSON","parse","s","version","initialState","catch","code","stateMirror","Waterfall","baseCreateStore","save","debounce","writeAsStringAsync","stringify","wait","maxWait","subscribe","actionName","stateFragmentResult"],"mappings":"svBAIA,SAASA,iBAAiBC,cAAQC,4DAC1BC,iCAGQC,IAAIC,MAAM,KAAMC,qCAGhBC,MAAMF,MAAM,KAAMC,+BAGlBE,gBAAWC,gDAEf,YACG,iBAEE,oBACNC,IAAIH,MAAMI,GACTA,eAEK,oBACND,IAAIH,MAAMI,GACTA,IAGJC,EAAOC,EAAEC,SAAUX,EAAUD,UAE5B,IAAIa,QAAQ,SAACC,EAASC,OACnBC,EAA2CN,EAA3CM,QAASR,EAAkCE,EAAlCF,IAAKS,EAA6BP,EAA7BO,YAAaC,EAAgBR,EAAhBQ,cAC/BC,mCAA4BH,QAC5BH,QAAQ,SAACC,EAASC,mBACTK,kBAAkBJ,GAC1BK,KAAK,gBACAC,EAAQC,KAAKC,MAAMC,GAClBH,GAASA,EAAMI,SAAW3B,EAAO4B,aAAaD,WAO7CP,MAAM,iBAAkBG,KACrBK,8BAAoBL,MAPvBH,uCACwBG,EAAMI,uBAC9B3B,EAAO4B,aAAaD,4BAQlB3B,KAET6B,MAAM,YACU,oBAAXnB,EAAEoB,OACAV,MAAM,2CAEEV,KAENV,OAEXsB,KAAK,gBACFS,EAAcnB,EAAEC,SAAUb,EAAO4B,gBACjCR,MAAM,mBAAoBpB,OACxBgC,EAAYC,gBAAgBjC,GAE9BkC,EAAOtB,EAAEuB,SACX,2BACaC,mBAAmBnB,EAASO,KAAKa,UAAUN,IACnDT,KAAK,aACAF,MAAM,kBAAmBW,KAE9BF,MAAMV,IAEXR,EAAKwB,SAASG,cACH3B,EAAKwB,SAASI,YAEjBC,UAAU,SAASC,EAAYC,KACnCtB,MAAM,kBAAmBsB,KAC3B7B,MAAMkB,EAAaW,WAGfV"}